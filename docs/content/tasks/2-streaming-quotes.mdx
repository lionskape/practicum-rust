# Задача 1. Генератор и читатель котировок

## Первое приложение: генератор котировок (Quote Server)

Это приложение будет выполнять роль сервера.
- Генерация данных. Создайте функцию, которая генерирует искусственные данные о ценах акций (например, для тикеров "AAPL", "GOOGL", "TSLA"). Данные должны включать тикер, цену, объём и timestamp. Цены должны периодически меняться, например, случайным блужданием.
   Пример:
   ```rust
    #[derive(Debug, Clone)]
    pub struct StockQuote {
        pub ticker: String,
        pub price: f64,
        pub volume: u32,
        pub timestamp: u64,
    }

    // Методы для сериализации/десериализации
    impl StockQuote {
        pub fn to_string(&self) -> String {
            format!("{}|{}|{}|{}", self.ticker, self.price, self.volume, self.timestamp)
        }

        pub fn from_string(s: &str) -> Option<Self> {
            let parts: Vec<&str> = s.split('|').collect();
            if parts.len() == 4 {
                Some(StockQuote {
                    ticker: parts[0].to_string(),
                    price: parts[1].parse().ok()?,
                    volume: parts[2].parse().ok()?,
                    timestamp: parts[3].parse().ok()?,
                })
            } else {
                None
            }
        }

        // Или бинарная сериализация
        pub fn to_bytes(&self) -> Vec<u8> {
            let mut bytes = Vec::new();
            bytes.extend_from_slice(self.ticker.as_bytes());
            bytes.push(b'|');
            bytes.extend_from_slice(self.price.to_string().as_bytes());
            bytes.push(b'|');
            bytes.extend_from_slice(self.volume.to_string().as_bytes());
            bytes.push(b'|');
            bytes.extend_from_slice(self.timestamp.to_string().as_bytes());
            bytes
        }
    }
   ```
   Volume (объём) в биржевых данных показывает количество акций, которые были проданы/куплены за определённый период времени — обычно за одну сделку или за торговую сессию.
   Пример:
   ```rust
    impl QuoteGenerator {
        pub fn generate_quote(&mut self, ticker: &str) -> Option<StockQuote> {
            // ... логика изменения цены ...

            let volume = match ticker {
                // Популярные акции имеют больший объём
                "AAPL" | "MSFT" | "TSLA" => 1000 + (rand::random::<f64>() * 5000.0) as u32,
                // Обычные акции - средний объём
                _ => 100 + (rand::random::<f64>() * 1000.0) as u32,
            };

            Some(StockQuote {
                ticker: ticker.to_string(),
                price: *last_price,
                volume,
                timestamp: SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_millis() as u64,
            })
        }
    }
   ```
- TCP-сервер. Ваше приложение должно запускать TCP-сервер, который принимает команды от клиентов.
- Протокол команд. Продумайте текстовый или бинарный протокол для команд. Минимальная команда должна позволять клиенту указать:
  - Адрес и порт, на который нужно отправлять данные по UDP.
  - Список тикеров (акций), которые клиент хочет получать (фильтрация).
  - Пример команды: STREAM udp://127.0.0.1:34254 AAPL,TSLA.
- Обработка команды. При получении валидной команды STREAM:
  - Сервер создаёт новый поток (thread) для этого конкретного клиента.
  - В этом потоке сервер начинает отправлять сгенерированные данные (только для запрошенных тикеров) на указанный UDP-адрес.
- Механизм Ping/Pong (Keep-Alive):
  - В основном потоке сервера (или в специальном потоке мониторинга) должна быть реализована логика ожидания "Ping" сообщений от клиента.
  - Клиент должен отправлять "Ping" сообщения по UDP на тот же сокет, с которого сервер отправляет данные.
  - Если в течение заданного тайм-аута (например, 5 секунд) от клиента не приходит "Ping", сервер должен остановить стриминг данных для этого клиента и завершить соответствующий поток.
- Многопоточность. Каждый новый UDP-стрим для клиента и основной генератор данных должны работать в отдельных потоках. Генератор данных при этом остаётся один на всё приложение. Используйте каналы (std::sync::mpsc) для передачи данных между потоком-генератором и потоками-отправителями. В Rust mpmc channels есть только в nightly, поэтому потребуется написать дополнительную функциональность для того, чтобы single consumer мог делить данные на всех клиентов. Либо можно использовать готовое решение из [crossbeam](https://docs.rs/crossbeam/latest/crossbeam/channel/index.html) — в рамках проектной работы это уместно.

## Второе приложение: клиент котировок (Quote Client)
Это приложение будет подключаться к серверу и получать данные.
- Интерфейс. Приложение должно предоставлять способ указать:
  - Адрес и порт TCP-сервера
  - Порт для приёма UDP-данных
  - Путь к файлу со списком тикеров для подписки
Рекомендуется реализовать это через аргументы командной строки с помощью крейта clap.
- Формат файла тикеров. Тикеры должны быть перечислены по одному на строку. Пример:
```
AAPL
GOOGL
TSLA
```
- Отправка команды. Клиент должен подключиться к TCP-серверу (Генератору) и отправить команду STREAM с нужными параметрами.
- Приём UDP-данных. После отправки команды клиент должен:
  - Создать UDP-сокет для приёма данных на указанный в команде порт.
  - В основном потоке начать получать и выводить в консоль приходящие котировки.
- Поток для Ping. Параллельно (в отдельном потоке) клиент должен периодически (например, каждые 2 секунды) отправлять "Ping" сообщение на UDP-адрес сервера — на тот же адрес и порт, с которого приходят данные.
- Обработка завершения. Клиент должен корректно обрабатывать завершение работы (например, по нажатию Ctrl+C), закрывая соединения и останавливая потоки.

## Как проверить себя перед отправкой работы на ревью

### Убедитесь, что:
- Собраны два приложения: quote_server (или server) и quote_client (или client).
- Cargo-проект компилируется без ошибок.
- Сервер запускается и слушает TCP-порт.
- Клиент может подключиться к серверу по TCP и отправить команду.
- Клиент корректно читает файл с тикерами и использует их для фильтрации.
- После отправки команды клиент начинает получать UDP-пакеты с котировками только для запрошенных тикеров.
- Клиент отправляет Ping-сообщения.
- Если клиент перестаёт отправлять Ping (можно симулировать, остановив клиент или добавив задержку), сервер в течение тайм-аута останавливает стриминг для этого клиента.
- Код использует многопоточность: для генератора данных и для каждого клиентского стрима создаются отдельные потоки.

### На что мы будем обращать внимание при проверке:
- Чистота и читаемость кода: осмысленные имена переменных и функций, отсутствие «магических чисел», комментарии к сложным логическим блокам.
- Обработка ошибок: код должен корректно обрабатывать сетевые ошибки, разрывы соединений, невалидные данные.
- Архитектура и организация кода: логическое разделение на модули/функции, отсутствие дублирования кода.
- Корректность работы с ресурсами: потоки, сокеты и каналы должны управляться правильно (например, избегая deadlock'ов в каналах).
- Следование ТЗ: реализованы все заявленные функции, включая фильтрацию по тикерам и механизм Keep-Alive.

### Чек-листы самопроверки перед ревью

#### Сборка и структура проекта
- В репозитории присутствуют два бинарных приложения: server и client.
- Проект компилируется без ошибок (cargo build проходит успешно).
- Структура проекта логична: код разбит на функции и модули, общие структуры вынесены в lib.rs.
- В Cargo.toml корректно настроены обе бинарные цели.
- README.md содержит описание запуска и структуры команд.

#### TCP-взаимодействие (инициализация соединения)
- Сервер запускается и слушает TCP-порт.
- Клиент подключается по TCP к серверу без ошибок.
- Клиент отправляет корректную команду STREAM udp://<ip>:<port> <tickers>.
- Сервер правильно парсит команду, проверяет параметры и отвечает OK.
- При ошибке в формате команды сервер возвращает ERR <сообщение>.

#### UDP-стриминг данных (основная логика)
- После команды STREAM сервер начинает отправку данных по UDP.
- Каждому клиенту соответствует отдельный поток отправки.
- Формат данных — JSON-структура {"ticker":"AAPL","price":...,"volume":...,"timestamp":...}.
- Клиент принимает и парсит UDP-сообщения без ошибок.
- Клиент выводит только запрошенные тикеры (фильтрация работает корректно).
- При потере пакета или ошибке приёма приложение не падает (обработка ошибок есть).

#### Keep-Alive (Ping/Pong-механизм)
- Клиент каждые 2 секунды отправляет PING по UDP на адрес сервера.
- Сервер получает Ping и обновляет время активности клиента.
- При отсутствии Ping более 5 секунд сервер прекращает стриминг конкретного клиента.
- После тайм-аута поток клиента корректно завершается, ресурсы освобождаются.
- Повторное подключение нового клиента не нарушает работу существующих потоков.

#### Многопоточность и синхронизация
- Генератор котировок работает в отдельном потоке.
- Каждый активный клиент обслуживается в своём потоке.
- Используются безопасные для потоков примитивы (Arc, Mutex, mpsc, Atomic).
- Нет гонок данных или взаимных блокировок.
- Завершение потоков происходит корректно — без зависаний.

#### Работа с файлами и аргументами
- Клиент принимает аргументы через clap: --server-addr, --udp-port, --tickers-file.
- Файл тикеров читается построчно, игнорируются пустые строки и пробелы.
- При отсутствии файла или ошибке чтения выводится понятная ошибка.

#### Обработка ошибок и завершение
- Все сетевые операции обёрнуты в Result, нет безусловных unwrap().
- Ошибки TCP/UDP соединений корректно обрабатываются и логируются.
- При нажатии Ctrl+C клиент корректно завершает работу и закрывает потоки.
- Сервер корректно освобождает ресурсы после остановки клиента.
- При повторном запуске без перезапуска процесса порты освобождены.

#### Качество и архитектура кода
- Имена переменных и функций осмысленные, отражают назначение.
- Нет дублирования кода между клиентом и сервером (общие типы вынесены в библиотеку).
- В коде есть комментарии к сложным блокам (многопоточность, обработка команд).
- Тайм-ауты, интервалы и порты вынесены в константы, нет «магических чисел».
- Используется логирование (log, env_logger), а не println! для служебных сообщений.